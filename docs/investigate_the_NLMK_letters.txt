curl 'https://www.meteoswiss.admin.ch/static/mch-precipitation-map.f0ba5350c8ca8757a781.js' \
  -H 'accept: */*' \
  -H 'accept-language: en-US,en;q=0.9,de-CH;q=0.8,de;q=0.7,ru-RU;q=0.6,ru;q=0.5' \
  -H 'cache-control: no-cache' \
  -b '_ga_KPF7TQ1BJY=GS1.1.1738232653.1.1.1738232802.0.0.0; _ga_59R4EB0KYN=GS2.1.s1750890645$o1$g1$t1750890664$j41$l0$h0; _ga_SY487S5SWP=GS2.1.s1751495030$o7$g0$t1751495030$j60$l0$h0; _ga=GA1.1.863850099.1737919781; _ga_SCXQ4XPN65=GS2.1.s1758715448$o3$g1$t1758715867$j57$l0$h0; _pk_id.1.c149=79449b5212b64d34.1764787942.; _pk_ses.1.c149=1' \
  -H 'dnt: 1' \
  -H 'pragma: no-cache' \
  -H 'referer: https://www.meteoswiss.admin.ch/services-and-publications/applications/precipitation.html' \
  -H 'sec-ch-ua: "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"' \
  -H 'sec-ch-ua-mobile: ?0' \
  -H 'sec-ch-ua-platform: "Windows"' \
  -H 'sec-fetch-dest: script' \
  -H 'sec-fetch-mode: no-cors' \
  -H 'sec-fetch-site: same-origin' \
  -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'

{
    1569: (e, t, r) => {
        r.d(t, {
            Zc: () => m,
            c5: () => p,
            uz: () => s
        });
        var o = r(38e3)
          , a = r(41594)
          , i = r(8342)
          , n = r(17377)
          , l = r(95546)
          , c = r(11961)
          , d = r(1761);
        const s = ({type: e, imageUrl: t, maskSwitzerland: r, customLayers: c, showPauseButton: s, showMyLocations: m=!1, pauseButtonCallbackFn: u}) => {
            const {persistentMyLocations: h} = (0,
            n.q)()
              , b = (0,
            i.s)(h, m)
              , [_,w] = (0,
            a.useState)(void 0)
              , f = (0,
            a.useRef)(void 0)
              , x = (0,
            a.useRef)(void 0)
              , v = (0,
            a.useRef)(!1)
              , y = (0,
            a.useCallback)(( () => {
                if (!v.current && (!_ && void 0 === x.current || f.current !== x.current))
                    if (x.current) {
                        v.current = !0;
                        const t = x.current;
                        f.current = t,
                        fetch(x.current).then((e => e.json())).then((r => {
                            x.current !== t ? (v.current = !1,
                            setTimeout(( () => y()), 0)) : (w(g(e, r)),
                            v.current = !1)
                        }
                        )).catch((e => {
                            v.current = !1,
                            console.error(`Error fetching data from ${t}`, e)
                        }
                        ))
                    } else {
                        const t = g(e, d.r);
                        w(t)
                    }
            }
            ), [t, e])
              , k = (0,
            a.useCallback)(( () => {
                y()
            }
            ), [y]);
            return (0,
            a.useEffect)(( () => {
                _ || void 0 !== x.current || (x.current = t,
                y()),
                t !== x.current && (x.current = t,
                v.current || setTimeout(( () => y()), 50))
            }
            ), [y, _, x]),
            (0,
            o.jsx)(o.Fragment, {
                children: _ ? (0,
                o.jsx)(l.A, {
                    showBorder: !0,
                    showCities: !0,
                    showMyLocations: !0,
                    swissAreaColor: "white",
                    customLayers: [p(e)],
                    showWaterAboveCustomLayers: !0,
                    showReliefAboveCustomLayers: !0,
                    maskSwitzerland: r,
                    customSources: Object.assign(Object.assign({}, _), {
                        "my-locations": {
                            type: "geojson",
                            data: {
                                type: "FeatureCollection",
                                features: b
                            }
                        }
                    }),
                    onIdle: k,
                    customLayersAboveBorder: c,
                    showPauseButton: s,
                    pauseButtonCallbackFn: u,
                    icons: {
                        star: "/static/resources/interactive-map/star.png"
                    }
                }) : null
            })
        }
          , p = e => ({
            id: "overlay_" + e,
            type: "fill",
            source: e,
            paint: {
                "fill-color": ["get", "color"],
                "fill-opacity": 1
            }
        })
          , g = (e, t) => ({
            [e]: m(t)
        })
          , m = e => {
            let t = 0;
            const r = [];
            let o = !1;
            if (e.areas.length > 0 && e.areas[0].shapes.forEach((e => o = o || e.length > 1)),
            o)
                for (; ; ) {
                    let o = -1;
                    if (e.areas.forEach((a => {
                        const i = [];
                        a.shapes.forEach((r => {
                            const a = r[0].l;
                            a === t ? i.push(r.map((t => u(t, e.coords)))) : a > t && (-1 === o || a < o) && (o = a)
                        }
                        )),
                        i.length && r.push({
                            type: "Feature",
                            properties: {
                                color: "#" + a.color
                            },
                            geometry: {
                                type: "MultiPolygon",
                                coordinates: i
                            }
                        })
                    }
                    )),
                    -1 == o)
                        break;
                    t = o
                }
            else
                for (; ; ) {
                    let o = -1
                      , a = "ffffff";
                    if (e.areas.map((i => {
                        i.shapes.forEach((n => {
                            n.forEach(( (n, l) => {
                                if (n.l === t) {
                                    const t = u(n, e.coords);
                                    t.length > 0 && r.push({
                                        type: "Feature",
                                        properties: {
                                            color: "#" + (0 == l ? i.color : a)
                                        },
                                        geometry: {
                                            type: "Polygon",
                                            coordinates: [t]
                                        }
                                    })
                                } else
                                    n.l > t && (-1 === o || n.l < o) && (o = n.l)
                            }
                            ))
                        }
                        )),
                        a = i.color
                    }
                    )),
                    -1 === o)
                        break;
                    t = o
                }
            return {
                type: "geojson",
                data: {
                    type: "FeatureCollection",
                    features: r
                }
            }
        }
          , u = (e, t) => {
            let r = e.i
              , o = e.j;
            const a = [];
            let i = 0;
            for (; i < e.o.length; ) {
                let n = 0
                  , l = 0;
                const d = parseInt(e.o.charAt(i)) / 10 + .05;
                r % 2 == 0 ? (n = t.x_min + (t.x_max - t.x_min) * (r / 2) / t.x_count,
                l = t.y_min + (t.y_max - t.y_min) * ((o - 1) / 2 + d) / t.y_count) : (n = t.x_min + (t.x_max - t.x_min) * ((r - 1) / 2 + d) / t.x_count,
                l = t.y_min + (t.y_max - t.y_min) * (o / 2) / t.y_count);
                const [s,p] = c.UH.CHtoWGS(1e3 * n, 1e3 * l);
                a.push([s, p]),
                2 * i < e.d.length && (r += e.d.charCodeAt(2 * i) - 77,
                o += e.d.charCodeAt(2 * i + 1) - 77),
                i++
            }
            return a
        }
    }
}